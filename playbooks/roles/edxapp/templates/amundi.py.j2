# -*- coding: utf-8 -*-
# TODO :
#When session manager is finalized
#Clean up all logs used for debug only, clean code, put credentials in the proper place and not "hardcoded"
from social_core.utils import handle_http_errors
from social_core.backends.oauth import BaseOAuth2, BaseOAuth1
from social_core.exceptions import AuthMissingParameter
from social_core.utils import url_add_parameters
import jwt
from pprint import pformat
from student.models import User
import re
from urllib import unquote
from base64 import b64decode
from django.conf import settings

import logging
import json
log = logging.getLogger(__name__)

class AmundiOAuth2(BaseOAuth2):
   """Amundi OAuth authentication backend"""
   name = 'amundi'
   ID_KEY = 'id'
   REDIRECT_STATE = False
   STATE_PARAMETER = True
   AUTHORIZATION_URL = 'https://sso.intramundi.com/oidc/authorize/phileas'
   ACCESS_TOKEN_URL = 'https://sso.intramundi.com/oidc/token/phileas'
   ACCESS_TOKEN_METHOD = 'POST'
   USER_INFO_URL = 'https://sso.intramundi.com/oidc/userinfo/phileas'
   USER_INFO_METHOD = 'GET'
   DEFAULT_SCOPE = None
   EXTRA_DATA = [
       ('id', 'id'),
       ('expires', 'expires')
   ]

   def get_user_details(self, response):
       """Return user details from Amundi account"""
       log.info("[get_user_details] first_name: "+str(self.data['given_name'].encode('iso-8859-1')))
       user_locale = "fr"
       if "locale" in self.data:
           user_locale = self.data['locale']
       return {'username': self.data['login'],
               'email': self.data['email'],
               'first_name': self.data['given_name'].encode('iso-8859-1'),
               'last_name': self.data['family_name'].encode('iso-8859-1'),
               'fullname': self.data['given_name'].encode('iso-8859-1') + ' ' + self.data['family_name'].encode('iso-8859-1'),
               'language': user_locale,
               'is_manager': self.data['is_manager'],
               'iug': self.data['iug'],
               'service': self.data['service'].encode('iso-8859-1'),
               'societe_id': self.data['societe.id'],
               'societe_name': self.data['societe.name'].encode('iso-8859-1'),
               'zoneinfo': self.data['zoneinfo']
       }

   def user_data(self, access_token, *args, **kwargs):
       """Loads user data from service"""
       params = {
            'access_token': access_token
       }
       data = {}
       headers = {}
       user_info = {}
       try:
           user_info = self.get_json(
               self.USER_INFO_URL,
               data=data,
               params=params,
               headers=headers,
               method=self.USER_INFO_METHOD
           )

           log.info("[user_data] json from userinfo: "+pformat(user_info))
           self.data = user_info
           log.info("[user_data] self.data updated with userinfo")
           return user_info
       except ValueError:
           return None

   def get_redirect_uri(self, state=None):
       """Build redirect with redirect_state parameter."""
       uri = self.redirect_uri
       uri = uri.replace("http:","https:")
       if self.REDIRECT_STATE and state:
           uri = url_add_parameters(uri, {'redirect_state': state})
       return uri

   def get_key_and_secret(self):
       client_id = ''
       client_secret = ''
       try:
           microsite = self.redirect_uri.split('//',1)[1].split('/',1)[0].split('.',1)[0].lower()
           log.info("microsite: "+str(microsite))
           client_id = json.loads(self.setting('KEY'))[microsite]
           client_secret = json.loads(self.setting('SECRET'))[microsite]
       except:
           client_id = 'default'
           client_secret = 'default'

       return client_id, client_secret

   def get_user_id(self, details, response):
       """Return a unique ID for the current user, by default from server
       response."""
       return self.data.get(self.ID_KEY)

   def auth_extra_arguments(self):
        return {
            'scope': 'offline_access+email+profile+address+phone'
        }

   @handle_http_errors
   def auth_complete(self, *args, **kwargs):
        """Completes login process, must return user instance"""
        self.process_error(self.data)
        log.info('[auth_complete] process_error : OK')
        state = self.validate_state()
        log.info('[auth_complete] state validated')
        log.info('[auth_complete] Will request access token '+pformat(self.access_token_url())+" data "+pformat(self.auth_complete_params(state))+" headers "+pformat(self.auth_headers())+" crede "+pformat(self.auth_complete_credentials()))
        try:
            response = self.request_access_token(
                self.access_token_url(),
                data=self.auth_complete_params(state),
                headers=self.auth_headers(),
                auth=self.auth_complete_credentials(),
                method=self.ACCESS_TOKEN_METHOD
            )
        except:
            log.info('Exception was: ', exc_info=True)
        self.process_error(response)
        log.info('[auth_complete] access token obtained: '+pformat(response['access_token']))
        return self.do_auth(response['access_token'], response=response, *args, **kwargs)

   @handle_http_errors
   def do_auth(self, access_token, *args, **kwargs):
        """Finish the auth process once the access_token was retrieved"""
        data = self.user_data(access_token, *args, **kwargs)
        response = kwargs.get('response') or {}
        response.update(data or {})
        if 'access_token' not in response:
            response['access_token'] = access_token
        kwargs.update({'response': response, 'backend': self})
        return self.strategy.authenticate(*args, **kwargs)


